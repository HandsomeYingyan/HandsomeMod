From fefbf1fb4f9b9a8d164c8a255ca886a27ee19cd1 Mon Sep 17 00:00:00 2001
Message-Id: <fefbf1fb4f9b9a8d164c8a255ca886a27ee19cd1.1587150132.git.zanussi@kernel.org>
In-Reply-To: <05c07aad7517537dec221029782bf891341897c5.1587150132.git.zanussi@kernel.org>
References: <05c07aad7517537dec221029782bf891341897c5.1587150132.git.zanussi@kernel.org>
From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date: Thu, 21 Sep 2017 14:25:13 +0200
Subject: [PATCH 261/506] RCU: we need to skip that warning but only on
 sleeping locks

This check is okay for upstream. On RT we trigger this while blocking on
sleeping lock. In this case, it is okay to schedule() within a RCU
section.
Since spin_lock() and read_lock() disables migration it should be okay
to test for this as an indication whether or not a sleeping lock is
held. The ->pi_blocked_on member won't work becasuse it might also be
set on regular mutexes.

Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
---
 kernel/rcu/tree_plugin.h | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/kernel/rcu/tree_plugin.h b/kernel/rcu/tree_plugin.h
index 181e2487c8b8..787321ad4f5f 100644
--- a/kernel/rcu/tree_plugin.h
+++ b/kernel/rcu/tree_plugin.h
@@ -323,9 +323,13 @@ static void rcu_preempt_note_context_switch(bool preempt)
 	struct task_struct *t = current;
 	struct rcu_data *rdp;
 	struct rcu_node *rnp;
+	int mg_counter = 0;
 
 	RCU_LOCKDEP_WARN(!irqs_disabled(), "rcu_preempt_note_context_switch() invoked with interrupts enabled!!!\n");
-	WARN_ON_ONCE(!preempt && t->rcu_read_lock_nesting > 0);
+#if defined(CONFIG_PREEMPT_COUNT) && defined(CONFIG_SMP)
+	mg_counter = t->migrate_disable;
+#endif
+	WARN_ON_ONCE(!preempt && t->rcu_read_lock_nesting > 0 && !mg_counter);
 	if (t->rcu_read_lock_nesting > 0 &&
 	    !t->rcu_read_unlock_special.b.blocked) {
 
-- 
2.17.1

